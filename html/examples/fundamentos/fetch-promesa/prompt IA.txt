Simulador Asíncrono (fetch y Promesas/Async-Await):

Objetivo: Visualizar cómo JavaScript maneja operaciones que toman tiempo (como llamadas de red) sin bloquear la interfaz, introduciendo el Event Loop, las Web APIs y la cola de microtareas.

Actores: Motor JS (Call Stack), Navegador (Web APIs - como fetch), Event Loop, Microtask Queue, Task Queue (opcional, para setTimeout), Servidor (simulado).

Ejemplo: Un botón que al hacer clic llama a una función JS que usa fetch para "obtener" datos de una URL simulada, y luego actualiza un div con la respuesta usando .then() o async/await. Incluir un console.log antes y después de la llamada a fetch.

Visualización:

- Panel Izquierdo: Botón y div de resultados. Código JS con fetch.

- Panel Central (Superior): "Call Stack": Muestra las funciones que se están ejecutando sincrónicamente.

- Panel Central (Inferior): "Web APIs / Background": Muestra tareas delegadas al navegador (ej. "Petición fetch en progreso...").

- Panel Derecho (Superior): "Microtask Queue": Muestra las funciones callback de las promesas (.then, .catch, await) esperando a ser ejecutadas.

- Panel Derecho (Medio): "Task Queue": (Opcional) Muestra callbacks de setTimeout, eventos DOM, etc.

- Panel Derecho (Inferior): "Log / Consola Simulada": Muestra console.log y el estado de la petición/respuesta.

Pasos Simulados: Clic -> JS añade función al Call Stack -> Se ejecuta console.log (antes) -> Se ejecuta fetch -> fetch se pasa a Web APIs -> fetch devuelve una Promesa (pendiente) -> Se ejecuta console.log (después) -> Función sale del Call Stack -> Petición de red simulada (en Web APIs) -> Respuesta del Servidor (simulada) -> Navegador añade el callback .then o la continuación de await a la Microtask Queue -> Event Loop ve Call Stack vacío, procesa Microtask Queue -> Callback va al Call Stack -> JS ejecuta el callback -> Actualiza el DOM -> Callback sale del Call Stack.