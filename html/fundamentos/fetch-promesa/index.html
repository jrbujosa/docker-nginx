<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador Asincron칤a JavaScript</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Simulador Interactivo: Comprendiendo la Asincron칤a (fetch y Event Loop)</h1>

    <div id="simulator-container">
        <!-- Panel Izquierdo: Control y C칩digo -->
        <div id="panel-control" class="panel">
            <h2>Panel de Control y C칩digo</h2>
            <button id="simulate-btn">Iniciar Simulaci칩n GET (Async/Await)</button>
            <p><strong>C칩digo que se ejecutar치:</strong></p>
            <pre><code id="code-snippet">
// (El c칩digo se cargar치 aqu칤 con JavaScript)
            </code></pre>
            <p><strong>Resultado de la Operaci칩n:</strong></p>
            <div id="result-div" class="output-box">Esperando acci칩n...</div>
        </div>

        <!-- Panel Central: Event Loop -->
        <div id="panel-eventloop" class="panel">
            <h2>Modelo de Concurrencia y Event Loop</h2>
            <div class="event-loop-diagram">
                <div class="diagram-box" id="call-stack">
                    <strong>Call Stack (Pila)</strong>
                    <div id="call-stack-content" class="diagram-content">(Vac칤o)</div>
                </div>
                <div class="diagram-box" id="web-apis">
                    <strong>Web APIs (Navegador)</strong>
                    <div id="web-apis-content" class="diagram-content">(Inactivo)</div>
                </div>
                <div class="diagram-box" id="callback-queue">
                    <strong>Callback Queue (Cola)</strong>
                    <div id="callback-queue-content" class="diagram-content">(Vac칤a)</div>
                </div>
                 <div id="event-loop-icon">游댃<br>Event Loop</div>
            </div>
             <p>(Visualizaci칩n simplificada)</p>
        </div>

        <!-- Panel Derecho: Log -->
        <div id="panel-log" class="panel">
            <h2>Registro de Eventos / Consola Simulada</h2>
            <div id="console-log" class="output-box console">
                <!-- Los mensajes aparecer치n aqu칤 -->
            </div>
        </div>
    </div>

    <div id="explanations">
        <h2>Ejemplo Async/Wait</h2>

        <div class="explanation-block">

<p> <a href="/examples/js/api-js/bd.html"> Acceso a una API REST que devuelve informaci칩n de usuarios, clientes y productos</a> </p>

<p> <a href="/examples/js/github/index.html"> Explorador de Repositorios de GitHub.</a> </p>

<p> <a href="/examples/js/api-ia/index.html"> Interacci칩n con la API de Gemini a trav칠s de un backend intermedio implementado en PHP.</a> </p>

<p> <a href="/examples/node/index.html"> Lista de Tareas Simple (API REST) con Node.js</a> </p>

<p> <a href="/examples/js/api-js/lista-usuarios.html"> Lista de Usuarios (API REST) con Node.js </a> </p>

        </div>

        <h2>Explicaciones Detalladas</h2>
        <details>
            <summary>Comunicaci칩n sincr칩na y as칤ncrona con HTTP</summary>
<h2>Tipos de Comunicaci칩n HTTP</h2>

<p>La siguiente tabla ilustra las diferentes formas en que un cliente (como un navegador web) puede comunicarse con un servidor web utilizando el protocolo HTTP, espec칤ficamente los m칠todos GET y POST. Se distinguen dos tipos de comunicaci칩n: sincr칩nica, donde el cliente espera una respuesta completa antes de continuar, y asincr칩nica, que permite al cliente continuar procesando mientras espera la respuesta del servidor (generalmente utilizando t칠cnicas como async/await o promesas). La tabla proporciona ejemplos comunes de c칩mo se implementa cada tipo de comunicaci칩n en el desarrollo web.</p>

<table>
  <thead>
    <tr>
      <th>Tipo de Comunicaci칩n</th>
      <th>Sincr칩nico</th>
      <th>Asincr칩nico (con <code>async/await</code> o promesas)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>GET</strong></td>
      <td>
        &lt;a&gt; (enlaces a otras p치ginas)<br>
        &lt;form method="GET"&gt; (env칤o tradicional de formularios que recargan la p치gina)
      </td>
      <td>
        <code>fetch</code> API con <code>async/await</code> o promesas (ej: <code>async function getData() { const response = await fetch('/api/data'); const data = await response.json(); return data; }</code>)<br>
        
      </td>
    </tr>
    <tr>
      <td><strong>POST</strong></td>
      <td>
        &lt;form method="POST"&gt; (env칤o tradicional de formularios que recargan la p치gina)
      </td>
      <td>
        <code>fetch</code> API con <code>async/await</code> o promesas (ej: <code>async function postData(data) { const response = await fetch('/api/submit', { method: 'POST', body: JSON.stringify(data) }); const result = await response.json(); return result; }</code>)<br>
       </td>
    </tr>
  </tbody>
</table>
        </details>


        <details>
            <summary>쯇or Qu칠 Asincron칤a? El Problema del Bloqueo</summary>
            <p>JavaScript, en su n칰cleo, es un lenguaje de un solo hilo (single-threaded). Esto significa que solo puede hacer una cosa a la vez. Si inicias una tarea que toma mucho tiempo (como descargar un archivo grande de un servidor) de forma s칤ncrona, todo el navegador se congelar칤a. El usuario no podr칤a hacer clic en botones, escribir o interactuar con la p치gina hasta que esa tarea termine. 춰Ser칤a una experiencia terrible!</p>
            <p>La <strong>asincron칤a</strong> resuelve esto. Permite iniciar tareas largas (como llamadas de red con `fetch` o temporizadores con `setTimeout`) y dejar que se ejecuten en segundo plano (manejadas por el navegador a trav칠s de las Web APIs). Mientras tanto, JavaScript puede continuar ejecutando otro c칩digo, manteniendo la interfaz de usuario responsiva.</p>
            <p>Cuando la tarea en segundo plano termina, su funci칩n de "respuesta" (callback) se pone en una cola. El Event Loop se encarga de mover esa funci칩n a la pila de llamadas (Call Stack) para que se ejecute, pero solo cuando la pila est칠 vac칤a.</p>
            <p><code>fetch</code> es la API moderna est치ndar en JavaScript para realizar solicitudes de red (HTTP) de forma as칤ncrona.</p>
        </details>


        <details>
            <summary>El Modelo de Concurrencia: Desglose del Diagrama</summary>
            <p>El diagrama simplificado muestra los componentes clave que permiten a JavaScript manejar la asincron칤a en el entorno del navegador:</p>
            <ul>
                <li><strong>Call Stack (Pila de Llamadas):</strong>
                    <ul>
                        <li>Es donde se ejecuta el c칩digo JavaScript s칤ncrono.</li>
                        <li>Cuando se llama a una funci칩n, se a침ade ("push") a la cima de la pila.</li>
                        <li>Cuando una funci칩n termina (`return` o fin), se quita ("pop") de la pila.</li>
                        <li>Funciona bajo el principio LIFO (Last-In, First-Out): la 칰ltima funci칩n en entrar es la primera en salir.</li>
                        <li>Si la pila se llena demasiado (ej: recursi칩n infinita), ocurre un "Stack Overflow".</li>
                    </ul>
                </li>
                 <li><strong>Web APIs (APIs del Navegador):</strong>
                    <ul>
                        <li>No son parte del motor JavaScript en s칤, sino funcionalidades proporcionadas por el navegador.</li>
                        <li>Incluyen: `fetch`, `setTimeout`, `setInterval`, manipulaci칩n del DOM, eventos (clics, etc.).</li>
                        <li>Cuando llamas a una de estas APIs (ej: `fetch(url)`), el navegador toma el control de esa tarea y la ejecuta en segundo plano.</li>
                        <li>Una vez que la tarea de la Web API termina (ej: se recibe la respuesta de red, o el temporizador expira), prepara una funci칩n (callback) para ser ejecutada.</li>
                    </ul>
                </li>
                 <li><strong>Callback Queue (Cola de Tareas / Task Queue):</strong>
                    <ul>
                        <li>Es una lista de espera para las funciones (callbacks) que est치n listas para ejecutarse despu칠s de que su tarea en la Web API haya terminado.</li>
                        <li>Funciona bajo el principio FIFO (First-In, First-Out): la primera funci칩n en llegar a la cola es la primera en ser considerada para ejecuci칩n.</li>
                        <li>Las funciones en esta cola esperan a que el Call Stack est칠 completamente vac칤o.</li>
                        <li><em>(Nota avanzada: Existe tambi칠n una Microtask Queue, prioritaria, para callbacks de Promesas como `.then()` y `await`, pero para simplificar, aqu칤 las agrupamos conceptualmente).</em></li>
                    </ul>
                </li>
                <li><strong>Event Loop (Bucle de Eventos):</strong>
                    <ul>
                        <li>Es el coraz칩n del modelo de concurrencia. Es un proceso que se ejecuta constantemente.</li>
                        <li>Su trabajo es simple: 쮼st치 el Call Stack vac칤o?</li>
                        <li>Si el Call Stack est치 vac칤o, revisa la Callback Queue (priorizando Microtasks si las hubiera).</li>
                        <li>Si hay alguna funci칩n esperando en la cola, el Event Loop la toma (la primera) y la empuja ("push") al Call Stack para que se ejecute.</li>
                        <li>Este ciclo continuo permite que las operaciones as칤ncronas se integren de nuevo en el flujo de ejecuci칩n s칤ncrono sin bloquear.</li>
                    </ul>
                </li>
            </ul>
        </details>

        <details>
            <summary>Manejando la Respuesta (`fetch`)</summary>
            <p>La funci칩n `fetch` inicia la solicitud de red y devuelve inmediatamente una <strong>Promesa</strong>. Una Promesa es un objeto que representa la eventual finalizaci칩n (o fallo) de una operaci칩n as칤ncrona.</p>
            <ul>
                <li><strong>Objeto `Response`:</strong> Cuando la Promesa de `fetch` se resuelve con 칠xito (se recibe una respuesta del servidor, incluso si es un error HTTP como 404 o 500), lo hace con un objeto `Response`. Este objeto contiene informaci칩n sobre la respuesta:
                    <ul>
                        <li>`response.ok`: Un booleano que es `true` si el c칩digo de estado HTTP est치 en el rango 200-299 (칠xito).</li>
                        <li>`response.status`: El c칩digo de estado num칠rico (ej: 200, 404, 500).</li>
                        <li>`response.statusText`: El mensaje de estado (ej: "OK", "Not Found").</li>
                        <li>`response.headers`: Un objeto para acceder a las cabeceras de la respuesta.</li>
                    </ul>
                </li>
                <li><strong>Leer el Cuerpo (Body):</strong> El objeto `Response` no contiene directamente los datos del cuerpo. Proporciona m칠todos as칤ncronos (que tambi칠n devuelven Promesas) para leerlo en diferentes formatos:
                    <ul>
                        <li>`response.json()`: Lee el cuerpo y lo parsea como JSON. Falla si el cuerpo no es JSON v치lido.</li>
                        <li>`response.text()`: Lee el cuerpo como texto plano.</li>
                        <li>`response.blob()`: Lee el cuerpo como un objeto Blob (datos binarios).</li>
                        <li><code>await response.json()</code> o <code>response.json().then(datos => ...)</code></li>
                    </ul>
                </li>
                <li><strong>Manejo de Errores:</strong> Es crucial manejar tanto los errores de red (no se pudo conectar) como los errores HTTP (respuesta recibida pero con estado de error).
                    <ul>
                        <li>Con `async/await`: Usa un bloque `try...catch`. El `catch` atrapar치 errores de red y errores lanzados manualmente (ej: `if (!response.ok) throw new Error(...)`).</li>
                        <li>Con `.then()`: Usa un `.catch(error => ...)` al final de la cadena de promesas. Recuerda verificar `response.ok` dentro del `.then()` que recibe la respuesta.</li>
                    </ul>
                    <pre><code class="small-code">// Ejemplo con async/await
try {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Error HTTP: ${response.status}`);
  }
  const data = await response.json();
  // ... usar data
} catch (error) {
  console.error("Fall칩 la solicitud:", error);
}</code></pre>
                </li>
            </ul>
        </details>

        <details>
            <summary>Depuraci칩n con Chrome DevTools (o similar)</summary>
            <p>Las herramientas de desarrollador del navegador son esenciales para trabajar con JavaScript y solicitudes de red.</p>
            <ul>
                <li><strong>Abrir DevTools:</strong> Presiona `F12` en Chrome/Edge/Firefox, o haz clic derecho en la p치gina y selecciona "Inspeccionar" o "Inspeccionar elemento".</li>
                <li><strong>Pesta침a `Console` (Consola):</strong>
                    <ul>
                        <li>Muestra los mensajes de `console.log()`, `console.warn()`, `console.error()`.</li>
                        <li>Muestra errores de JavaScript que ocurren en la p치gina.</li>
                        <li>Puedes escribir y ejecutar c칩digo JavaScript directamente aqu칤.</li>
                        <li>Ver치s los logs de nuestro simulador aqu칤 tambi칠n (adem치s de la consola simulada).</li>
                    </ul>
                </li>
                <li><strong>Pesta침a `Network` (Red):</strong>
                    <ul>
                        <li>Registra todas las solicitudes de red que realiza la p치gina (HTTP, im치genes, CSS, JS).</li>
                        <li>Para cada solicitud (`fetch` real), puedes ver: M칠todo (GET/POST), URL, C칩digo de estado, Cabeceras (Headers), Payload (datos enviados en POST), Respuesta (Response) del servidor.</li>
                        <li>Es fundamental para depurar problemas con APIs: 쯉e envi칩 la solicitud correctamente? 쯈u칠 respondi칩 el servidor?</li>
                        <li>*Nota: Nuestro simulador usa `setTimeout`, as칤 que NO ver치s una entrada real en la pesta침a Network para la operaci칩n simulada.*</li>
                    </ul>
                </li>
                 <li><strong>Pesta침a `Sources` (Fuentes):</strong>
                    <ul>
                        <li>Permite ver los archivos fuente (HTML, CSS, JS) de la p치gina.</li>
                        <li>Puedes establecer **breakpoints** haciendo clic en el n칰mero de l칤nea del c칩digo JS. La ejecuci칩n se pausar치 cuando llegue a ese punto.</li>
                        <li>Mientras est치 pausado, puedes inspeccionar el valor de las variables, ver el **Call Stack** real en ese momento, y ejecutar el c칩digo paso a paso.</li>
                    </ul>
                </li>
            </ul>
        </details>

        <details>
            <summary>Glosario de T칠rminos</summary>
            <dl>
                <dt>S칤ncrono</dt><dd>Las operaciones se ejecutan una despu칠s de la otra, en orden. Una operaci칩n debe terminar antes de que comience la siguiente. Puede causar bloqueo.</dd>
                <dt>As칤ncrono</dt><dd>Las operaciones pueden iniciarse y ejecutarse en segundo plano, permitiendo que otro c칩digo contin칰e. La finalizaci칩n se maneja posteriormente (con callbacks, promesas, async/await).</dd>
                <dt>Bloqueante</dt><dd>Una operaci칩n que impide que otro c칩digo (especialmente en el hilo principal) se ejecute hasta que ella misma termine. T칤pico de operaciones s칤ncronas largas.</dd>
                <dt>No Bloqueante</dt><dd>Una operaci칩n que no impide la ejecuci칩n de otro c칩digo mientras se realiza. T칤pico de operaciones as칤ncronas.</dd>
                <dt>Callback</dt><dd>Una funci칩n que se pasa como argumento a otra funci칩n, para ser ejecutada m치s tarde, t칤picamente cuando una operaci칩n as칤ncrona se completa.</dd>
                <dt>Promesa (Promise)</dt><dd>Un objeto que representa el resultado eventual (칠xito o fallo) de una operaci칩n as칤ncrona. Permite encadenar operaciones con `.then()` y manejar errores con `.catch()`.</dd>
                <dt>async/await</dt><dd>Sintaxis moderna (az칰car sint치ctico sobre Promesas) que permite escribir c칩digo as칤ncrono que se lee de forma similar al c칩digo s칤ncrono, usando `async` para definir la funci칩n y `await` para esperar la resoluci칩n de una Promesa.</dd>
                <dt>fetch</dt><dd>API moderna del navegador para realizar solicitudes HTTP as칤ncronas. Devuelve Promesas.</dd>
                <dt>API (Application Programming Interface)</dt><dd>Conjunto de reglas y protocolos que permiten que diferentes componentes de software se comuniquen entre s칤 (ej: Web APIs del navegador, APIs de servidores web).</dd>
                <dt>HTTP (HyperText Transfer Protocol)</dt><dd>El protocolo fundamental para la transferencia de datos en la World Wide Web.</dd>
                <dt>GET</dt><dd>M칠todo HTTP para solicitar/recuperar datos de un servidor.</dd>
                <dt>POST</dt><dd>M칠todo HTTP para enviar datos a un servidor, usualmente para crear o modificar recursos.</dd>
                <dt>Event Loop</dt><dd>Mecanismo en entornos como navegadores o Node.js que gestiona la ejecuci칩n de c칩digo, eventos y callbacks, permitiendo la concurrencia no bloqueante en un solo hilo.</dd>
                <dt>Call Stack</dt><dd>Estructura de datos que rastrea las funciones en ejecuci칩n en un programa.</dd>
                <dt>Callback Queue</dt><dd>Cola donde se almacenan los callbacks listos para ser ejecutados una vez que el Call Stack est칠 vac칤o.</dd>
                <dt>Web APIs</dt><dd>Funcionalidades expuestas por el navegador (DOM, fetch, setTimeout, etc.) que pueden ejecutarse en segundo plano.</dd>
                <dt>DOM (Document Object Model)</dt><dd>Representaci칩n en memoria de la estructura de un documento HTML/XML, que JavaScript puede manipular.</dd>
                <dt>JSON (JavaScript Object Notation)</dt><dd>Formato ligero de intercambio de datos, f치cil de leer para humanos y f치cil de parsear para m치quinas.</dd>
                <dt>Idempotente</dt><dd>Una operaci칩n que produce el mismo resultado si se ejecuta una o m칰ltiples veces.</dd>
            </dl>
        </details>

         <details>
            <summary>Pr칩ximos Pasos / Para Explorar</summary>
             <ul>
                 <li>Experimenta cambiando el tiempo de retraso en `simulatedFetch` en `script.js`.</li>
                 <li>Intenta a침adir otro bot칩n para simular un error (modificando `simulatedFetch` para que a veces llame a `reject` o devuelva `ok: false`).</li>
                 <li>Investiga la diferencia entre la Macro Task Queue y la Micro Task Queue (donde van las promesas).</li>
                 <li>Intenta implementar la versi칩n con `.then()` adem치s de `async/await`.</li>
                 <li>Explora c칩mo funcionar칤a una simulaci칩n de POST (necesitar칤as pasar `options` a `simulatedFetch`).</li>
             </ul>
        </details>
    </div>

    <script src="script.js"></script>
</body>
</html>