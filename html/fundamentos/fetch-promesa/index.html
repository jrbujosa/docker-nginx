<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8"> <!-- Corregido de UTF-P a UTF-8 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador Asincron√≠a JavaScript (Paso a Paso)</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Simulador Interactivo: Comprendiendo la Asincron√≠a (fetch y Event Loop)</h1>

    <div id="controls">
        <button id="reset-btn">Iniciar / Reiniciar Simulaci√≥n</button>
        <button id="prev-step-btn" disabled>Paso Anterior</button>
        <button id="next-step-btn" disabled>Siguiente Paso</button>
        <label style="margin-left: 20px;">
            <input type="checkbox" id="simulate-error-checkbox"> Simular Error en la Red
        </label>
    </div>

    <div id="current-step-explanation-container" class="panel">
        <h2>Explicaci√≥n del Paso Actual:</h2>
        <p id="current-step-text">Presiona "Iniciar / Reiniciar Simulaci√≥n" y luego "Siguiente Paso" para comenzar.</p>
    </div>

    <div id="simulator-container">
        <!-- Panel Izquierdo: Control y C√≥digo -->
        <div id="panel-control" class="panel">
            <h2>Panel de C√≥digo</h2>
            <p><strong>C√≥digo que se est√° "ejecutando":</strong></p>
            <pre><code id="code-snippet">
    // (El c√≥digo se cargar√° aqu√≠ con JavaScript)
            </code></pre>
            <p><strong>Resultado de la Operaci√≥n:</strong></p>
            <div id="result-div" class="output-box">Esperando acci√≥n...</div>
        </div>

        <!-- Panel Central: Event Loop -->
        <div id="panel-eventloop" class="panel">
            <h2>Modelo de Concurrencia y Event Loop</h2>
            <div class="event-loop-diagram">
                <div class="diagram-box" id="call-stack">
                    <strong>Call Stack (Pila de Llamadas)</strong>
                    <div id="call-stack-content" class="diagram-content">(Vac√≠o)</div>
                </div>
                <div class="diagram-box" id="web-apis">
                    <strong>Web APIs (Navegador)</strong>
                    <div id="web-apis-content" class="diagram-content">(Inactivo)</div>
                </div>
                <div class="diagram-box" id="callback-queue">
                    <strong>Callback Queue (Cola de Tareas)</strong>
                    <div id="callback-queue-content" class="diagram-content">(Vac√≠a)</div>
                </div>
                 <div id="event-loop-icon">üîÑ<br>Event Loop</div>
            </div>
             <p>(Visualizaci√≥n simplificada)</p>
        </div>

        <!-- Panel Derecho: Log -->
        <div id="panel-log" class="panel">
            <h2>Registro de Eventos / Consola Simulada</h2>
            <div id="console-log" class="output-box console">
                <!-- Los mensajes aparecer√°n aqu√≠ -->
            </div>
        </div>
    </div>

    <div id="explanations">
        <h2>Ejemplo Async/Wait</h2>
        <div class="explanation-block">
            <p> <a href="/examples/js/api-js/bd.html"> Acceso a una API REST que devuelve informaci√≥n de usuarios, clientes y productos</a> </p>
            <p> <a href="/examples/js/github/index.html"> Explorador de Repositorios de GitHub.</a> </p>
            <p> <a href="/examples/js/api-ia/index.html"> Interacci√≥n con la API de Gemini a trav√©s de un backend intermedio implementado en PHP.</a> </p>
            <p> <a href="/examples/node/index.html"> Lista de Tareas Simple (API REST) con Node.js</a> </p>
            <p> <a href="/examples/js/api-js/lista-usuarios.html"> Lista de Usuarios (API REST) con Node.js </a> </p>
        </div>

        <h2>Explicaciones Detalladas</h2>

        <details open> <!-- Abierto por defecto para que sea lo primero que vean -->
            <summary><strong>Fundamentos: ¬øC√≥mo funciona la Asincron√≠a en JavaScript?</strong></summary>
            <p>JavaScript, por s√≠ mismo, solo puede hacer una cosa a la vez (es "de un solo hilo"). Entonces, ¬øc√≥mo es que puede manejar tareas largas sin que toda la p√°gina se congele? Aqu√≠ est√° el secreto:</p>

            <h4>1. La "Magia" de la Asincron√≠a: Delegaci√≥n Inteligente</h4>
            <p>La clave no es que JavaScript haga m√∫ltiples cosas al mismo tiempo, sino que <strong>delega</strong> las tareas largas (como pedir datos a un servidor con <code>fetch</code>, o esperar con <code>setTimeout</code>) a otras partes del entorno donde se ejecuta (generalmente el navegador web o Node.js).</p>
            <ul>
                <li><strong>JavaScript dice:</strong> "Navegador, por favor, haz esta petici√≥n de red (<code>fetch</code>) y av√≠same cuando termines."</li>
                <li><strong>El Navegador (sus Web APIs):</strong> Se encarga de la tarea en segundo plano.</li>
                <li><strong>JavaScript (mientras tanto):</strong> ¬°Queda libre para hacer otras cosas! No se queda esperando.</li>
                <li><strong>Cuando la tarea termina:</strong> El navegador prepara una funci√≥n de "respuesta" (llamada <em>callback</em>) y la pone en una lista de espera (la Callback Queue).</li>
                <li><strong>El Event Loop:</strong> Es un vigilante constante. Cuando ve que JavaScript no est√° ocupado (el Call Stack est√° vac√≠o) y hay algo en la lista de espera, toma esa funci√≥n de respuesta y se la da a JavaScript para que la ejecute.</li>
            </ul>
            <p>As√≠, JavaScript puede iniciar muchas tareas "largas" y seguir respondiendo a interacciones del usuario, manteniendo la p√°gina fluida.</p>

            <h4>2. ¬øQu√© puede estar haciendo JavaScript mientras "espera" una tarea as√≠ncrona?</h4>
            <p>Cuando una funci√≥n <code>async</code> est√° "pausada" en un <code>await</code> (esperando que una Promesa se resuelva), el motor de JavaScript <em>realmente</em> est√° libre. Podr√≠a estar haciendo:</p>
            <ul>
                <li><strong>Ejecutando otro c√≥digo s√≠ncrono:</strong> Si en tu script principal, despu√©s de llamar a tu funci√≥n <code>async</code>, tienes m√°s c√≥digo como <code>console.log("El script principal contin√∫a...");</code>, ese c√≥digo se ejecutar√≠a.</li>
                <li><strong>Respondiendo a interacciones del usuario:</strong> Si el usuario hace clic en un bot√≥n, mueve el rat√≥n, o escribe, y tienes funciones (<em>event listeners</em>) para manejar esas acciones, esas funciones podr√≠an ejecutarse. El navegador pone el <em>callback</em> del evento en la "Callback Queue", y el Event Loop lo pasar√° al Call Stack cuando est√© libre.</li>
                <li><strong>Ejecutando callbacks de temporizadores:</strong> Si tienes temporizadores (<code>setTimeout</code> o <code>setInterval</code>) que se cumplen, sus funciones <em>callback</em> se a√±aden a la "Callback Queue" y pueden ser ejecutadas.</li>
                <li><strong>Procesando otras Promesas (tareas de alta prioridad):</strong> Si otras Promesas se resuelven, sus funciones <em>callback</em> (las que pones en <code>.then()</code> o las continuaciones de otros <code>await</code>) se ponen en una cola especial de "alta prioridad" (Microtask Queue) y se ejecutan tan pronto como el Call Stack est√© libre, incluso antes que las tareas de la "Callback Queue" normal.</li>
            </ul>

            <h4>3. ¬øD√≥nde se especifican estas "otras cosas" y en qu√© orden se hacen?</h4>
            <ul>
                <li><strong>Especificadas en tu c√≥digo:</strong>
                    <ul>
                        <li>El "otro c√≥digo s√≠ncrono" son simplemente las l√≠neas siguientes en tu archivo <code>.js</code>.</li>
                        <li>Los manejadores de eventos se definen con <code>elemento.addEventListener('click', function() { /* c√≥digo aqu√≠ */ });</code>.</li>
                        <li>Los temporizadores con <code>setTimeout(function() { /* c√≥digo aqu√≠ */ }, tiempoDeEspera);</code>.</li>
                        <li>Otras Promesas y sus manejadores <code>.then()</code> o <code>await</code> estar√°n en otras partes de tu c√≥digo.</li>
                    </ul>
                </li>
                <li><strong>Orden de ejecuci√≥n (controlado por el Event Loop):</strong>
                    <ol>
                        <li><strong>C√≥digo S√≠ncrono Inicial:</strong> Se ejecuta de arriba abajo.</li>
                        <li><strong>Microtask Queue (Promesas, alta prioridad):</strong> Cuando el Call Stack se vac√≠a, el Event Loop revisa esta cola. Si hay tareas, las ejecuta TODAS hasta que la cola est√© vac√≠a.</li>
                        <li><strong>Actualizaci√≥n de Pantalla (Render):</strong> El navegador puede aprovechar para redibujar la p√°gina si es necesario.</li>
                        <li><strong>Macrotask Queue (Callback Queue en el simulador - eventos, temporizadores):</strong> Si la Microtask Queue est√° vac√≠a, el Event Loop toma UNA tarea de esta cola y la pasa al Call Stack para ejecutarla.</li>
                        <li><strong>Repetir:</strong> El ciclo (Microtasks -> Render -> Un Macrotask) contin√∫a.</li>
                    </ol>
                </li>
            </ul>
            <p><em>Nota: En nuestro simulador, para simplificar, la "Callback Queue" representa principalmente la Macrotask Queue.</em></p>
        </details>

        <details>
            <summary><strong>¬øQu√© son `async` y `await`? (Y la funci√≥n `simulatedFetch`)</strong></summary>
            <p><code>async</code> y <code>await</code> son palabras clave especiales en JavaScript que nos ayudan a trabajar con operaciones as√≠ncronas (como pedir datos a un servidor) de una manera m√°s limpia y f√°cil de leer. ¬°Hacen que el c√≥digo as√≠ncrono parezca casi s√≠ncrono!</p>
            <h4><code>async function</code></h4>
            <ul>
                <li>Al poner <code>async</code> antes de <code>function</code>, le dices a JavaScript dos cosas:
                    <ol>
                        <li>Esta funci√≥n va a trabajar con operaciones as√≠ncronas de una manera especial.</li>
                        <li>Esta funci√≥n <strong>siempre devolver√° una Promesa</strong>. Si la funci√≥n devuelve un valor normal (ej: <code>return 10;</code>), JavaScript autom√°ticamente envolver√° ese valor en una Promesa que se resuelve con <code>10</code>. Si la funci√≥n lanza un error, la Promesa devuelta ser√° rechazada con ese error.</li>
                    </ol>
                </li>
            </ul>
            <h4><code>await</code></h4>
            <ul>
                <li>La palabra clave <code>await</code> <strong>solo se puede usar DENTRO de una funci√≥n <code>async</code></strong>.</li>
                <li>Cuando pones <code>await</code> delante de una expresi√≥n que devuelve una Promesa (como <code>await fetch(url)</code>):
                    <ol>
                        <li>La ejecuci√≥n de la funci√≥n <code>async</code> se <strong>pausa</strong> en ese punto.</li>
                        <li>JavaScript espera a que la Promesa se resuelva (se complete con √©xito) o se rechace (falle).</li>
                        <li><strong>Importante:</strong> Mientras est√° pausada, la funci√≥n <code>async</code> es temporalmente retirada del Call Stack, permitiendo que el motor JavaScript ejecute otro c√≥digo (ver la explicaci√≥n "Fundamentos" de arriba).</li>
                        <li>Si la Promesa se resuelve, <code>await</code> devuelve el valor con el que se resolvi√≥ (ej: el objeto `Response` de `fetch`).</li>
                        <li>Si la Promesa se rechaza, <code>await</code> lanza un error, que puedes atrapar con un bloque <code>try...catch</code>.</li>
                    </ol>
                </li>
            </ul>

            <h4>Tabla de Usos Comunes de `await`</h4>
            <table>
                <thead>
                    <tr>
                        <th>Operaci√≥n As√≠ncrona</th>
                        <th>Ejemplo con `await`</th>
                        <th>Qu√© hace `await`</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Pedir datos con `fetch` (del navegador)</td>
                        <td><code>const respuesta = await fetch(url);</code></td>
                        <td>Pausa la funci√≥n <code>async</code> hasta que el servidor responde y la Promesa de `fetch` se resuelve con un objeto `Response`.</td>
                    </tr>
                    <tr>
                        <td>Leer el cuerpo de la respuesta como JSON</td>
                        <td><code>const datos = await respuesta.json();</code></td>
                        <td>Pausa hasta que el cuerpo de la respuesta se lee y se convierte a un objeto JavaScript. La Promesa de `.json()` se resuelve con esos datos.</td>
                    </tr>
                    <tr>
                        <td>Leer el cuerpo de la respuesta como Texto</td>
                        <td><code>const texto = await respuesta.text();</code></td>
                        <td>Pausa hasta que el cuerpo de la respuesta se lee como una cadena de texto.</td>
                    </tr>
                    <tr>
                        <td>Esperar un tiempo (con una Promesa personalizada)</td>
                        <td><code>await new Promise(resolve => setTimeout(resolve, 1000));</code></td>
                        <td>Pausa la funci√≥n <code>async</code> durante 1 segundo (1000 milisegundos).</td>
                    </tr>
                    <tr>
                        <td>Llamar a otra funci√≥n `async`</td>
                        <td><code>const resultado = await otraFuncionAsync();</code></td>
                        <td>Pausa hasta que `otraFuncionAsync` (que tambi√©n devuelve una Promesa) se complete y devuelva su resultado.</td>
                    </tr>
                </tbody>
            </table>

            <h4>La Funci√≥n `simulatedFetch` en Este Simulador</h4>
            <p>En el c√≥digo de este simulador (archivo <code>script.js</code>), ver√°s una funci√≥n llamada <code>simulatedFetch</code>. Esta funci√≥n <strong>NO es la funci√≥n <code>fetch</code> real del navegador</strong>. Es una funci√≥n que hemos creado nosotros para <em>imitar</em> o <em>simular</em> c√≥mo se comporta <code>fetch</code>:</p>
            <ul>
                <li>Devuelve una Promesa.</li>
                <li>Simula un retraso de red usando <code>setTimeout</code> (una Web API real).</li>
                <li>Puede simular aleatoriamente un √©xito o un error.</li>
                <li>Si tiene √©xito, resuelve su Promesa con un objeto que se parece al objeto <code>Response</code> real (tiene una propiedad <code>ok</code> y un m√©todo <code>.json()</code>, que tambi√©n es simulado y devuelve otra Promesa).</li>
            </ul>
            <p>Usamos <code>simulatedFetch</code> para poder controlar y visualizar el flujo as√≠ncrono paso a paso dentro del simulador, sin hacer peticiones de red reales que podr√≠an variar en tiempo o fallar inesperadamente.</p>
        </details>


        <details>
            <summary>Comunicaci√≥n S√≠ncrona vs. As√≠ncrona (HTTP)</summary>
            <p>Cuando tu navegador pide informaci√≥n a un servidor (como cuando visitas una p√°gina web o una app carga datos), usa un protocolo llamado HTTP.</p>
            <ul>
                <li><strong>S√≠ncrono (como esperar en una fila):</strong> El navegador env√≠a una petici√≥n y se queda ESPERANDO hasta que el servidor responda. Mientras espera, no puede hacer mucho m√°s. Si tarda mucho, la p√°gina se siente "congelada".
                    <ul>
                        <li>Ejemplo: Hacer clic en un enlace normal <code><a href="..."></code> te lleva a otra p√°gina y tienes que esperar a que cargue por completo.</li>
                    </ul>
                </li>
                <li><strong>As√≠ncrono (como pedir comida para llevar y seguir haciendo cosas):</strong> El navegador env√≠a una petici√≥n, pero NO se queda esperando congelado. Sigue funcionando y haciendo otras cosas. Cuando el servidor responde, el navegador procesa esa respuesta. Esto hace que las p√°ginas sean m√°s fluidas.
                    <ul>
                        <li>Ejemplo: Usar <code>fetch</code> en JavaScript. Pides datos, la p√°gina sigue funcionando, y cuando los datos llegan, se muestran sin recargar todo.</li>
                    </ul>
                </li>
            </ul>
            <p>La tabla siguiente muestra ejemplos comunes:</p>
            <table>
              <thead>
                <tr>
                  <th>Tipo de Comunicaci√≥n</th>
                  <th>S√≠ncrono</th>
                  <th>Asincr√≥nico (con <code>async/await</code> o promesas)</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>GET (Pedir datos)</strong></td>
                  <td>
                    <code><a></code> (enlaces que recargan la p√°gina)<br>
                    <code><form method="GET"></code> (formularios que recargan)
                  </td>
                  <td>
                    <code>fetch('/api/datos')</code> con <code>async/await</code>.<br>
                    <em>(El navegador pide datos en segundo plano)</em>
                  </td>
                </tr>
                <tr>
                  <td><strong>POST (Enviar datos)</strong></td>
                  <td>
                    <code><form method="POST"></code> (formularios que recargan)
                  </td>
                  <td>
                    <code>fetch('/api/enviar', { method: 'POST', ... })</code> con <code>async/await</code>.<br>
                    <em>(El navegador env√≠a datos en segundo plano)</em>
                  </td>
                </tr>
              </tbody>
            </table>
        </details>

        <details>
            <summary>¬øPor Qu√© Asincron√≠a? El Problema del Bloqueo</summary>
            <p>Imagina que JavaScript es como un cocinero que solo puede hacer una cosa a la vez (es "single-threaded" o de un solo hilo).</p>
            <p>Si le pides que haga una tarea muy larga de forma <strong>s√≠ncrona</strong> (como hornear un pastel que tarda una hora), el cocinero se queda esperando frente al horno sin hacer nada m√°s. ¬°Toda la cocina (tu p√°gina web) se paraliza! No podr√≠as pedirle ni un vaso de agua (hacer clic en botones, escribir, etc.) hasta que el pastel est√© listo.</p>
            <p>La <strong>asincron√≠a</strong> es como si el cocinero pudiera poner el pastel en el horno (una tarea larga que delega al horno, una Web API) y, mientras se hornea, dedicarse a otras cosas (atender otros pedidos, limpiar - es decir, ejecutar otro c√≥digo JavaScript). Cuando el horno suena (la tarea termina y su callback llega a la Callback Queue), el cocinero (el Event Loop lo trae al Call Stack) va y saca el pastel.</p>
            <p>En JavaScript, tareas como pedir datos a un servidor (<code>fetch</code>) o esperar un tiempo (<code>setTimeout</code>) pueden ser as√≠ncronas. JavaScript las "delega" al navegador (a las Web APIs). Mientras el navegador se encarga de eso en segundo plano, JavaScript sigue ejecutando otro c√≥digo, manteniendo tu p√°gina web funcional y sin congelarse.</p>
            <p>Cuando la tarea en segundo plano termina, su "respuesta" (una funci√≥n llamada callback) se pone en una "sala de espera" (la Callback Queue). El "portero" (Event Loop) la lleva a ejecutarse solo cuando el cocinero (Call Stack) est√© libre.</p>
        </details>

        <details>
            <summary>El Modelo de Concurrencia: ¬øQu√© hace cada parte del diagrama?</summary>
            <p>El diagrama te muestra c√≥mo JavaScript maneja varias cosas "a la vez" (en realidad, gestionando tareas muy bien) sin bloquearse, usando estas partes:</p>
            <ul>
                <li><strong>Call Stack (Pila de Llamadas - "El Cocinero Haciendo Algo"):</strong>
                    <ul>
                        <li>Aqu√≠ es donde se ejecuta tu c√≥digo JavaScript, una instrucci√≥n tras otra.</li>
                        <li>Cuando llamas a una funci√≥n, se pone encima de la pila (como apilar platos).</li>
                        <li>Cuando una funci√≥n termina, se quita de la pila.</li>
                        <li>Solo se hace una cosa a la vez en la cima de la pila.</li>
                        <li>Si una funci√≥n <code>async</code> usa <code>await</code>, se pausa y es *temporalmente retirada* del Call Stack mientras espera. Visualmente en este simulador, la mantenemos para indicar que est√° "en espera".</li>
                    </ul>
                </li>
                 <li><strong>Web APIs (Ayudantes del Navegador - "El Horno, el Temporizador"):</strong>
                    <ul>
                        <li>Son herramientas que el navegador ofrece, pero no son parte de JavaScript directamente (ej: <code>fetch</code> para pedir datos, <code>setTimeout</code> para esperar).</li>
                        <li>Cuando JavaScript usa una Web API (ej: <code>fetch('url')</code>), le dice al navegador: "Oye, enc√°rgate de esto".</li>
                        <li>El navegador hace esa tarea en segundo plano (hornear el pastel, esperar). JavaScript no se queda esperando ah√≠.</li>
                        <li>Cuando la Web API termina su trabajo (datos recibidos, tiempo cumplido), avisa preparando una funci√≥n (callback).</li>
                    </ul>
                </li>
                 <li><strong>Callback Queue (Cola de Tareas / Task Queue - "La Fila de Espera"):</strong>
                    <ul>
                        <li>Es una lista de espera para las funciones (callbacks) que est√°n listas para ejecutarse.</li>
                        <li>Estas funciones vienen de las Web APIs que ya terminaron su trabajo (ej: el callback de un <code>setTimeout</code>, un manejador de evento de clic).</li>
                        <li>Las funciones esperan aqu√≠ en orden (la primera que llega es la primera en ser considerada).</li>
                        <li>Esperan a que el Call Stack (el cocinero) est√© completamente vac√≠o y que la cola de Microtasks (Promesas) tambi√©n est√© vac√≠a.</li>
                        <li><em>(Nota avanzada: Existe tambi√©n una Microtask Queue, prioritaria, para callbacks de Promesas como `.then()` y `await`, pero para simplificar, aqu√≠ las agrupamos conceptualmente o nos referimos a la Callback Queue para tareas de Web APIs como `setTimeout` o eventos).</em></li>
                    </ul>
                </li>
                <li><strong>Event Loop (Bucle de Eventos - "El Portero Inteligente"):</strong>
                    <ul>
                        <li>Es como un portero que mira constantemente: el Call Stack, la Microtask Queue y la Callback Queue (o Macrotask Queue).</li>
                        <li>Su trabajo es:
                            <ol>
                                <li>¬øEl Call Stack est√° vac√≠o?</li>
                                <li>Si S√ç, ¬øhay algo en la Microtask Queue (callbacks de Promesas)? Si S√ç, ejecuta TODAS las tareas de la Microtask Queue una por una.</li>
                                <li>Si el Call Stack est√° vac√≠o y la Microtask Queue tambi√©n, ¬øhay algo en la Callback Queue (eventos, setTimeout, etc.)? Si S√ç, toma la PRIMERA tarea y la pasa al Call Stack para que se ejecute.</li>
                            </ol>
                        </li>
                        <li>Este ciclo se repite una y otra vez, muy r√°pido. As√≠ es como las tareas as√≠ncronas vuelven a ejecutarse sin bloquear el flujo principal.</li>
                    </ul>
                </li>
            </ul>
        </details>

        <details>
            <summary>Manejando la Respuesta de `fetch` (Pedir Datos)</summary>
            <p>Cuando usas <code>fetch(url)</code> para pedir datos (o nuestra funci√≥n <code>simulatedFetch(url)</code> en este simulador):</p>
            <ol>
                <li><strong><code>fetch</code> devuelve una Promesa:</strong> Inmediatamente, <code>fetch</code> te da una "Promesa". Una Promesa es como un ticket que dice: "Te prometo que tendr√© un resultado para esto m√°s tarde (ya sea √©xito o error)". No te da los datos directamente.</li>
                <li><strong>Esperar la Promesa (con `await`):</strong> Si usas `async function` y `await`, tu funci√≥n se pausa en la l√≠nea del <code>await fetch(...)</code> hasta que la Promesa inicial se cumpla. Esto significa que el servidor ha respondido (o nuestra simulaci√≥n ha terminado su "retraso").</li>
                <li><strong>Objeto `Response`:</strong> Cuando la Promesa se cumple, obtienes un objeto `Response` (o un objeto simulado que se le parece). Este objeto tiene informaci√≥n sobre la respuesta:
                    <ul>
                        <li><code>response.ok</code>: Dice <code>true</code> si todo fue bien (c√≥digos de estado 200-299), o <code>false</code> si hubo un error HTTP (como 404 - No encontrado, 500 - Error del servidor). En nuestra simulaci√≥n, decidimos si es <code>true</code> o <code>false</code>.</li>
                        <li><code>response.status</code>: El n√∫mero del c√≥digo de estado (ej: 200, 404).</li>
                    </ul>
                </li>
                <li><strong>Leer los Datos Reales (el "cuerpo"):</strong> El objeto `Response` no tiene los datos directamente. Necesitas usar otro m√©todo as√≠ncrono (que tambi√©n devuelve una Promesa) para leer los datos:
                    <ul>
                        <li><code>await response.json()</code>: Si esperas datos en formato JSON (muy com√∫n en APIs). En nuestra simulaci√≥n, <code>simulatedFetch</code> devuelve un objeto con un m√©todo <code>.json()</code> que tambi√©n es simulado y devuelve otra Promesa.</li>
                        <li><code>await response.text()</code>: Si esperas texto plano.</li>
                    </ul>
                    Tu funci√≥n se pausar√° de nuevo en este `await` hasta que los datos se hayan le√≠do y procesado.
                </li>
                <li><strong>Manejo de Errores (¬°Muy Importante!):</strong>
                    <ul>
                        <li><strong>Errores de Red:</strong> Si no hay conexi√≥n a internet (o nuestra simulaci√≥n decide fallar as√≠), `fetch` fallar√° y la Promesa ser√° "rechazada". Un bloque `try...catch` atrapar√° este error.</li>
                        <li><strong>Errores HTTP (ej: 404, 500):</strong> `fetch` NO considera un error HTTP (como 404) como un fallo de la Promesa inicial. La Promesa se cumple, pero `response.ok` ser√° `false`. ¬°Debes comprobar `response.ok` t√∫ mismo!
                            <pre><code class="small-code">
if (!response.ok) {
  // Lanza un error para que lo capture el 'catch'
  throw new Error(`Error HTTP: ${response.status}`);
}
// Si llegas aqu√≠, response.ok es true
const data = await response.json();
                            </code></pre>
                        </li>
                        <li>El bloque <code>catch</code> en un <code>try...catch</code> es tu amigo para manejar cualquier problema que ocurra dentro del <code>try</code>.</li>
                    </ul>
                </li>
            </ol>
        </details>

        <details>
            <summary>Depuraci√≥n con Herramientas del Navegador (DevTools)</summary>
            <p>Las "Herramientas para Desarrolladores" (DevTools) de tu navegador son tus mejores amigas para entender y arreglar c√≥digo JavaScript.</p>
            <ul>
                <li><strong>Abrir DevTools:</strong> Usualmente con la tecla `F12`. O clic derecho en la p√°gina -> "Inspeccionar".</li>
                <li><strong>Pesta√±a `Console` (Consola):</strong>
                    <ul>
                        <li>Aqu√≠ ves los mensajes de `console.log()` (como los de nuestro simulador).</li>
                        <li>Muestra errores de JavaScript que ocurren.</li>
                        <li>Puedes escribir y probar c√≥digo JavaScript aqu√≠.</li>
                    </ul>
                </li>
                <li><strong>Pesta√±a `Network` (Red):</strong>
                    <ul>
                        <li>Muestra TODAS las peticiones de red que hace tu p√°gina (im√°genes, scripts, y ¬°las de `fetch`!).</li>
                        <li>Para cada petici√≥n `fetch` real, puedes ver la URL, el m√©todo (GET/POST), las cabeceras, y la respuesta del servidor. ¬°S√∫per √∫til para ver si tu API funciona!</li>
                        <li><em>(Nota: Nuestro simulador usa <code>simulatedFetch</code> que funciona con <code>setTimeout</code>, as√≠ que NO ver√°s una entrada de red real para la operaci√≥n simulada aqu√≠, ¬°pero s√≠ los `console.log` que la describen!)</em></li>
                    </ul>
                </li>
                 <li><strong>Pesta√±a `Sources` (Fuentes):</strong>
                    <ul>
                        <li>Puedes ver los archivos de tu p√°gina (HTML, CSS, JS).</li>
                        <li>Puedes poner **puntos de interrupci√≥n (breakpoints)** haciendo clic en el n√∫mero de l√≠nea de tu c√≥digo JS. Cuando el c√≥digo llegue ah√≠, la ejecuci√≥n se PAUSAR√Å.</li>
                        <li>Mientras est√° pausado, puedes ver el valor de las variables, el **Call Stack** real en ese momento, y avanzar paso a paso. ¬°Es como una lupa para tu c√≥digo!</li>
                    </ul>
                </li>
            </ul>
        </details>

        <details>
            <summary>Glosario (Palabras Clave)</summary>
            <dl>
                <dt>S√≠ncrono</dt><dd>Una cosa despu√©s de otra. La siguiente tarea no empieza hasta que la actual termina. Puede hacer que la p√°gina se "congele" si una tarea es larga.</dd>
                <dt>As√≠ncrono</dt><dd>Permite iniciar tareas (especialmente las largas) y seguir con otras cosas. La finalizaci√≥n se maneja posteriormente.</dd>
                <dt>Motor JavaScript</dt><dd>El programa (como V8 en Chrome) que interpreta y ejecuta tu c√≥digo JavaScript. Es de un solo hilo.</dd>
                <dt>Web APIs</dt><dd>Funcionalidades proporcionadas por el navegador (no por el motor JS en s√≠) como <code>fetch</code>, <code>setTimeout</code>, manipulaci√≥n del DOM. Pueden ejecutarse en segundo plano.</dd>
                <dt>Callback</dt><dd>Una funci√≥n que se pasa como argumento a otra funci√≥n, para ser ejecutada m√°s tarde (ej: cuando una tarea as√≠ncrona se completa).</dd>
                <dt>Promesa (Promise)</dt><dd>Un objeto que representa un valor que estar√° disponible en el futuro (el resultado de una operaci√≥n as√≠ncrona, ya sea √©xito o error).</dd>
                <dt>async/await</dt><dd>Palabras clave en JavaScript que facilitan escribir c√≥digo as√≠ncrono que usa Promesas, haci√©ndolo parecer m√°s s√≠ncrono.</dd>
                <dt>fetch</dt><dd>La forma moderna en JavaScript para pedir datos a servidores (APIs) de forma as√≠ncrona. Devuelve Promesas. En este simulador, usamos <code>simulatedFetch</code> para imitarla.</dd>
                <dt>Event Loop</dt><dd>El "director de orquesta" que revisa las colas de tareas (Microtask y Macrotask/Callback Queue) y, si el Call Stack est√° libre, las pasa para que se ejecuten.</dd>
                <dt>Call Stack</dt><dd>Donde se lleva la cuenta de qu√© funci√≥n se est√° ejecutando ahora mismo. Si una funci√≥n <code>async</code> est√° en <code>await</code>, t√©cnicamente se retira del Call Stack.</dd>
                <dt>Microtask Queue</dt><dd>Cola de alta prioridad para callbacks de Promesas resueltas. Se vac√≠a completamente antes de pasar a la Macrotask Queue.</dd>
                <dt>Callback Queue (o Macrotask Queue)</dt><dd>La "sala de espera" para callbacks de Web APIs como <code>setTimeout</code>, eventos de usuario, etc.</dd>
            </dl>
        </details>

         <details>
            <summary>Pr√≥ximos Pasos / Para Explorar</summary>
             <ul>
                 <li>Juega con la casilla "Simular Error en la Red" para ver c√≥mo cambia el flujo.</li>
                 <li>Observa atentamente c√≥mo cada l√≠nea de c√≥digo resaltada afecta el Call Stack, las Web APIs y la Callback Queue. Presta atenci√≥n especial a los pasos donde <code>obtenerDatos()</code> est√° "pausada".</li>
                 <li>Intenta predecir qu√© pasar√° en el siguiente paso antes de hacer clic en el bot√≥n.</li>
                 <li>Abre las DevTools de tu navegador (F12) y mira la pesta√±a "Console" para ver los logs reales que tambi√©n genera el simulador.</li>
                 <li>Compara la explicaci√≥n de `async/await` con el c√≥digo del simulador. ¬øPuedes identificar d√≥nde se usa `await` y qu√© Promesa est√° esperando?</li>
             </ul>
        </details>
    </div>

    <script src="script.js"></script>
</body>
</html>